<!DOCTYPE html>
<html lang="en">
<head>
  <!-- 2023-06-06 Tue 09:30 -->
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" type="text/css" href="../css/stylesheet.css" />
  <link rel="stylesheet" href="../highlight/styles/mj.css">
  <script src="../highlight/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
  <meta name="author" content="Mike Jones" />
  <title>mj - Fast Random Noise</title>
</head>
<body>

<div class="mj_image">
<p>
  <a href="../index.html" width="120px" height="115px" alt="mj"><img src="../data/mj.png" alt="mj" width="120px" height="115px" /></a>
</p>
</div>

<h1 class="title">Fast Random Noise</h1>
<small>20251014</small>
<p>
  Decent talk by Roth
  Michaels, <a href="https://youtu.be/N2AM6ixC6LI?si=ME0IMQ9zOzR2rvuK">ADC 2022
  Fast, High-quality Pseudo-random Numbers for Audio Developers</a>. There is
  some example code at the end too.
</p>
<p>
  I like that <a href="https://en.wikipedia.org/wiki/Xorshift">xoshiro</a> is
  pretty straightforward to implement. There are code examples on
  the <a href="https://prng.di.unimi.it">website</a> and
  a <a href="https://vigna.di.unimi.it/papers.php#BlVSLPNG">paper</a>.
</p>
<p>
  The authors recommend xorshiro128+ as suitable for floating point
  generation. There is a reference
  implementation <a href="https://prng.di.unimi.it/xoroshiro128plus.c">here</a>.
</p>
<p>
  <pre>
    <code>
static inline uint64_t rotl(const uint64_t x, int k) {
	return (x << k) | (x >> (64 - k));
}


static uint64_t s[2];

uint64_t next(void) {
	const uint64_t s0 = s[0];
	uint64_t s1 = s[1];
	const uint64_t result = s0 + s1;

	s1 ^= s0;
	s[0] = rotl(s0, 24) ^ s1 ^ (s1 << 16); // a, b
	s[1] = rotl(s1, 37); // c

	return result;
}
    </code>
  </pre>
</p>
<p>
  The conversion of <code>uint64_t</code> to a <code>float</code> (0 to 1) is a bit of a fiddle to get
  your head around, but it is neat to understand.
</p>
<p>
  <pre>
    <code>
/**
* 1. Extract 32bits
* 2. Drop the 8 bit mantissa
* 3. Mutliply by float32 precision
*/
//|------ 1 -----|-- 2 --|---- 3 ----|
((uint64_t >> 32u) >> 8) * 0x1.0p-24f;
    </code>
  </pre>
</p>
<p>
  The seed should be initialised
  using <a href="https://prng.di.unimi.it/splitmix64.c">SplitMix64</a>. Again
  very straightforward to implement.
</p>
<p>
  <pre>
    <code>
static uint64_t x; /* The state can be seeded with any value. */

uint64_t next() {
    uint64_t z = (x += 0x9e3779b97f4a7c15);
    z = (z ^ (z >> 30)) * 0xbf58476d1ce4e5b9;
    z = (z ^ (z >> 27)) * 0x94d049bb133111eb;
    return z ^ (z >> 31);
}
    </code>
  </pre>
</p>
<p>
  That just leaves the SplitMix64 state to be initialised. I use <code>std::random_device</code> to
  generate two <code>uint32_t</code>, and then bit shift to create a single <code>uint64_t</code>.
</p>
<p>
  <pre>
    <code>
std::random_device rdev;

uint64_t x = rdev();
// Fill the upper 32 bits
x <<= 32;
// Fill the lower 32 bits
x |= rdev();
    </code>
  </pre>
</p>
<p>
<a href="https://www.pcg-random.org/">PCG</a> could be used as an alternative to
xoshiro. I did not look into it much as implementing xoshiro was very
straightforward and it seems good enough for my needs.
</p>
</body>
</html>
