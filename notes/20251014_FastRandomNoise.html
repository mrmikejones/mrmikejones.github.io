<!DOCTYPE html>
<html lang="en">
<head>
  <!-- 2023-06-06 Tue 09:30 -->
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" type="text/css" href="../css/stylesheet.css" />
  <link rel="stylesheet" href="../highlight/styles/mj.css">
  <script src="../highlight/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
  <meta name="author" content="Mike Jones" />
  <title>mj - Fast Random Noise</title>
</head>
<body>

<div class="mj_image">
<p>
  <a href="../index.html" width="120px" height="115px" alt="mj"><img src="../data/mj.png" alt="mj" width="120px" height="115px" /></a>
</p>
</div>

<h1 class="title">Fast Random Noise</h1>
<small>20251014</small>
<p>
  Decent talk by Roth
  Michaels, <a href="https://youtu.be/N2AM6ixC6LI?si=ME0IMQ9zOzR2rvuK">ADC 2022
  Fast, High-quality Pseudo-random Numbers for Audio Developers</a>. There is
  some example code at the end too.
</p>
<p>
  I like that xoshiro is pretty straightforward to implement. There are code
  examples, and you can understand what the code is doing.
</p>
<p>
  The authors recommend xoshiro128+ for floating point generation. There is a reference
  implementation <a href="https://prng.di.unimi.it/xoshiro128plus.c">here</a>.
</p>
<p>
  <pre>
    <code>
static inline uint32_t rotl(const uint32_t x, int k) {
    return (x << k) | (x >> (32 - k));
}


static uint32_t s[4];

uint32_t next(void) {
    const uint32_t result = s[0] + s[3];

    const uint32_t t = s[1] << 9;

    s[2] ^= s[0];
    s[3] ^= s[1];
    s[1] ^= s[2];
    s[0] ^= s[3];

    s[2] ^= t;

    s[3] = rotl(s[3], 11);

    return result;
}
    </code>
  </pre>
</p>
<p>
  The conversion of <code>uint64_t</code> to a <code>float</code> (0 to 1) is a bit of a fiddle to get
  your head around, but it is neat to understand.
</p>
<p>
  <pre>
    <code>
/**
* 1. Extract 32bits
* 2. Drop the 8 bit mantissa
* 3. Mutliply by float32 precision
*/
//|------ 1 -----|-- 2 --|---- 3 ----|
((uint64_t >> 32u) >> 8) * 0x1.0p-24f;
    </code>
  </pre>
</p>
<p>
  The seed should be initialised
  using <a href="https://prng.di.unimi.it/splitmix64.c">SplitMix64</a>. Again
  very straightforward to implement.
</p>
<p>
  <pre>
    <code>
static uint64_t x; /* The state can be seeded with any value. */

uint64_t next() {
    uint64_t z = (x += 0x9e3779b97f4a7c15);
    z = (z ^ (z >> 30)) * 0xbf58476d1ce4e5b9;
    z = (z ^ (z >> 27)) * 0x94d049bb133111eb;
    return z ^ (z >> 31);
}
    </code>
  </pre>
</p>
<p>
  That just leaves the SplitMix64 state to be initialised. I use <code>std::random_device</code> to
  generate two <code>uint32_t</code>, and then bit shift to create a single <code>uint64_t</code>.
</p>
<p>
  <pre>
    <code>
std::random_device rdev;

uint64_t x = rdev();
// Fill the upper 32 bits
x <<= 32;
// Fill the lower 32 bits
x |= rdev();
    </code>
  </pre>
</p>
<p>
<a href="https://www.pcg-random.org/">PCG</a> could be used as an alternative to
xoshiro. I didn't look into it much as implementing xoshiro was very straightforward and it seems good enough for my needs.
</p>
<hr />
<ul>
  <li><a href="https://vigna.di.unimi.it/papers.php#BlVSLPNG">Scrambled Linear Pseudorandom Number Generators</a></li>
  <li><a href="https://prng.di.unimi.it">A PRNG Shootout</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Xorshift">Wikipedia - Xorshift</a></li>
</ul>
</body>
</html>
